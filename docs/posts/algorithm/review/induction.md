---
head:
  - - link
    - rel: stylesheet
      href: https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css
---
# 算法设计与分析 归纳

参考资料为算法黑皮书和红皮书第四版，任教老师为邱德红，作者Bolaxious。这门课的重点并不在于讲为了实现某种算法要怎么去写代码，而是讲一讲算法背后的设计和考虑。课程主要内容都在上一篇文章复习材料中提到并做了扩展，这里则提取主要知识点，不会关注细节例如某个算法的具体实现。

## 2021年考试题解答

![](2025-06-01-13-40-57.png)

根据题目要求，我们需要解答 2021 年的算法相关问题，并结合知识点进行分析。以下是针对每个问题的详细解答：

---

### **1. 简述三种算法效率符号**
#### **知识点：算法时间复杂度分析**
算法效率通常用大 O、Ω 和 Θ 符号来描述：
1. **大 O 符号 (O)**：
   - 描述算法在最坏情况下的上界。
   - 表示算法运行时间不会超过某个增长速率。
   - 例如，如果一个算法的时间复杂度是 $O(n^2)$，表示其运行时间在最坏情况下不会超过 $n^2$ 的常数倍。

2. **Ω 符号 (Ω)**：
   - 描述算法在最好情况下的下界。
   - 表示算法运行时间至少会达到某个增长速率。
   - 例如，如果一个算法的时间复杂度是 $\Omega(n)$，表示其运行时间在最好情况下至少是 $n$ 的常数倍。

3. **Θ 符号 (Θ)**：
   - 描述算法在平均情况或确切情况下的紧确界。
   - 表示算法运行时间既不会低于某个增长速率，也不会高于另一个增长速率。
   - 例如，如果一个算法的时间复杂度是 $\Theta(n \log n)$，表示其运行时间在所有情况下都与 $n \log n$ 同阶。

#### **总结**
- **大 O**：最坏情况的上界。
- **Ω**：最好情况的下界。
- **Θ**：平均或确切情况的紧确界。

---

### **2. 两种随机化算法及特征**
#### **知识点：随机化算法**
随机化算法利用随机性来提高算法的效率或简化实现。常见的随机化算法包括：
1. **快速选择（Quickselect）**：
   - **特征**：
     - 基于快速排序的思想，通过随机选择 pivot 来划分数组。
     - 时间复杂度：平均情况下为 $O(n)$，最坏情况下为 $O(n^2)$。
     - 应用：用于找到第 k 小的元素，如中位数。

2. **哈希表（Hash Table）**：
   - **特征**：
     - 使用哈希函数将键映射到数组中的位置。
     - 时间复杂度：平均情况下查找、插入和删除操作为 $O(1)$，但最坏情况下可能退化为 $O(n)$。
     - 应用：高效存储和检索数据，解决冲突（如开放寻址法或链地址法）。

#### **总结**
- **快速选择**：基于随机 pivot 的分治算法，用于寻找第 k 小的元素。
- **哈希表**：利用随机哈希函数实现高效的键值对存储和检索。

---

### **3. 字符编码 & 文本文件最短储存，字符编码的特点**
#### **知识点：字符编码与文本压缩**
1. **字符编码**：
   - **ASCII 编码**：
     - 每个字符占用 8 位（1 字节），支持 256 种不同的字符。
     - 特点：简单、固定长度，但无法表示中文等多字节字符。
   - **Unicode 编码**：
     - 支持全球范围内的字符集，包括中文、日文等。
     - 常见的 Unicode 编码方式有 UTF-8、UTF-16 等。
     - 特点：可变长度编码，兼容 ASCII，适合国际化需求。

2. **文本文件最短储存**：
   - **霍夫曼编码（Huffman Coding）**：
     - 根据字符出现频率动态分配码长，频率高的字符使用短码，频率低的字符使用长码。
     - 特点：无损压缩，适用于文本文件的高效存储。
   - **LZW 压缩（Lempel-Ziv-Welch Compression）**：
     - 基于字典的压缩方法，通过构建字符串字典来减少重复数据。
     - 特点：适用于具有大量重复模式的文本文件。

#### **总结**
- **字符编码**：ASCII 和 Unicode 是常用的字符编码方式，分别适用于简单的英文字符和国际化需求。
- **文本压缩**：霍夫曼编码和 LZW 压缩是常用的文本压缩算法，能够有效减少存储空间。

---

### **4. 分治法子问题的特点**
#### **知识点：分治法的核心思想**
分治法（Divide and Conquer）的基本步骤包括：
1. **分解（Divide）**：
   - 将原问题分解为若干个规模较小的子问题。
   - 子问题应相互独立，且与原问题形式相同。

2. **解决（Conquer）**：
   - 递归地求解各个子问题。
   - 如果子问题足够小，则直接求解。

3. **合并（Combine）**：
   - 将子问题的解合并为原问题的解。

#### **子问题的特点**：
1. **独立性**：
   - 子问题之间没有重叠，可以并行求解。
2. **同构性**：
   - 子问题与原问题具有相同的结构，便于递归求解。
3. **可合并性**：
   - 子问题的解可以通过某种方式合并为原问题的解。

#### **例子：归并排序（Merge Sort）**
- **分解**：将数组分成两半。
- **解决**：递归地对两半分别排序。
- **合并**：将两个有序子数组合并成一个有序数组。

#### **总结**
- 分治法的子问题应具备独立性、同构性和可合并性，以便高效地解决问题。

---

### **证明题：很简单的问题**
#### **知识点：算法正确性的证明**
以快速选择算法为例，证明其正确性：
1. **快速选择算法**：
   - 目标：在未排序数组中找到第 k 小的元素。
   - 步骤：
     1. 随机选择一个 pivot。
     2. 将数组分为小于 pivot 的部分和大于 pivot 的部分。
     3. 根据 pivot 的位置判断目标元素在哪一部分，递归求解。

2. **证明思路**：
   - **归纳法**：
     - 假设对于大小为 $n-1$ 的数组，快速选择算法能正确找到第 k 小的元素。
     - 对于大小为 $n$ 的数组，随机选择 pivot 后，根据 pivot 的位置调整 k 的值，递归求解。
   - **正确性保证**：
     - 每次划分后，pivot 的位置确定了它在数组中的排名。
     - 根据 pivot 的位置，可以准确判断目标元素在左半部分还是右半部分。

#### **总结**
- 快速选择算法的正确性可以通过归纳法证明，关键在于每次划分后 pivot 的位置能够准确反映其排名。

---

### **设计题：分治法求 n 元素数组中数量超过一半的元素**
#### **知识点：Boyer-Moore 投票算法**
1. **问题描述**：
   - 在一个包含 $n$ 个元素的数组中，找出一个出现次数超过 $\frac{n}{2}$ 的元素（若存在）。

2. **算法设计**：
   - **Boyer-Moore 投票算法**：
     1. 初始化候选者 `candidate` 和计数器 `count`。
     2. 遍历数组：
        - 如果当前元素等于 `candidate`，则 `count++`。
        - 如果当前元素不等于 `candidate`，则 `count--`。
        - 如果 `count == 0`，则更新 `candidate` 为当前元素。
     3. 验证 `candidate` 是否满足条件（即是否出现超过 $\frac{n}{2}$ 次）。

3. **时间复杂度**：
   - 第一遍遍历数组：$O(n)$。
   - 第二遍验证：$O(n)$。
   - 总复杂度：$O(n)$。

#### **总结**
- Boyer-Moore 投票算法是一种线性时间的分治思想应用，用于解决多数元素问题。

---

### **动态规划：批了一个称重外皮完全背包问题**
#### **知识点：完全背包问题**
1. **问题描述**：
   - 给定 $n$ 种物品，每种物品有无限供应，重量为 $w_i$，价值为 $v_i$，背包容量为 $W$。求装入背包的最大总价值。

2. **动态规划状态定义**：
   - 设 $dp[i][j]$ 表示前 $i$ 种物品中，背包容量为 $j$ 时的最大价值。
   - 状态转移方程：
     $dp[i][j] = \max(dp[i-1][j], dp[i][j-w_i] + v_i)$
   - 初始条件：
     $dp[0][j] = 0, \quad dp[i][0] = 0$

3. **优化空间复杂度**：
   - 由于状态转移只依赖于当前行和上一行，可以用一维数组实现：
     $dp[j] = \max(dp[j], dp[j-w_i] + v_i)$

#### **总结**
- 完全背包问题可以通过动态规划解决，状态转移方程的关键在于允许重复选取同一种物品。

---

### **贪心：教室安排（原题）**
#### **知识点：区间调度问题**
1. **问题描述**：
   - 有多个教室安排请求，每个请求包含开始时间和结束时间，求最多能安排多少个不重叠的教室。

2. **贪心策略**：
   - 按照结束时间从小到大排序。
   - 依次选择结束时间最早的请求，只要其开始时间不早于当前已安排的最后一个请求的结束时间。

3. **正确性证明**：
   - 贪心选择局部最优（最早结束的请求），全局最优（最多安排的请求）。
   - 可以通过交换论证证明贪心策略的正确性。

#### **总结**
- 教室安排问题可以通过贪心算法解决，核心是按照结束时间排序并选择不重叠的区间。

---

### **图论：最大流和最小割 & 3 * 3 的 Floyd**
#### **知识点：最大流与最小割**
1. **最大流问题**：
   - 使用 Ford-Fulkerson 方法或 Edmonds-Karp 算法求解。
   - 关键步骤：
     - 构建残余网络。
     - 寻找增广路径。
     - 更新流量直到找不到增广路径。

2. **最小割问题**：
   - 最大流最小割定理：最大流的值等于最小割的容量。
   - 可以通过最大流算法间接求解最小割。

#### **知识点：Floyd-Warshall 算法**
1. **问题描述**：
   - 求解所有顶点对之间的最短路径。
   - 输入是一个带权有向图，输出是一个 $n \times n$ 的矩阵，表示任意两点间的最短距离。

2. **算法步骤**：
   - 初始化距离矩阵 $D$。
   - 迭代更新：
     $D_{ij} = \min(D_{ij}, D_{ik} + D_{kj})$
   - 时间复杂度：$O(n^3)$。

#### **总结**
- 最大流和最小割问题可以通过 Ford-Fulkerson 或 Edmonds-Karp 算法求解。
- Floyd-Warshall 算法用于求解所有顶点对的最短路径，时间复杂度为 $O(n^3)$。

---

### **总结**
以上是对 2021 年算法相关问题的详细解答，涵盖了算法效率符号、随机化算法、字符编码、分治法、动态规划、贪心算法以及图论等内容。希望这些解答对你有所帮助！如果有进一步的问题，请随时提问。
























































































































































































































































































































