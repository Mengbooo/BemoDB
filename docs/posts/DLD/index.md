---
title: 复习#002 | 数字电路与逻辑设计
date: "2025-06-17"
tags:
  - DLD
  - 复习
---

# 复习#002 | 数字电路与逻辑设计

::: details
靠北，完全是预习欸 😭 所以软工学生为什么要学数字逻辑 😵
:::

<embed src="/BemoDB/DLDoutline.pdf" type="application/pdf" width="100%" height="900px" />

- 以及第二章的列表化简法不考

## 概述

在第一章我们应该了解几个基础概念：数字系统、计数制及其转换、带符号的二进制数的代码表示以及编码。

### 数字系统

先从数字系统讲起：

数字系统是一个能对数字信号进行加工、传递和存储的实体，它由实现各种功能的数字逻辑电路相互连接而成，例如脉冲计数电路、测控系统、计算机等等。

上面我们引入了几个新概念：数字信号和数字逻辑电路，我们来分别阐述：

#### 数字信号

引入两个前置概念：

自然界中形形色色的物理量，尽管它们的性质各异，但就其变化规律的特点而言，分为两大类。

- 一类物理量的变化在时间上和数量上都是离散的。这类物理量常称为数字量。
- 另一类物理量的变化在时间上和数量上则是连续的。这类物理量常称为模拟量。

用来表示数字量的信号叫数字信号。我们把工作在数字信号下的电子电路叫做数字电路。

反之则称为模电，幸好不用学。

我们再来对数字信号进行一个详细的阐述：

**若信号的变化在时间上和数值上都是离散的，或者说断续的，则称为离散信号。离散信号的变化可以用不同的数字反映，所以又称为数字信号，简称为数字量。**

例如，学生成绩记录，工厂产品统计，电路开关的状态等。

数字系统要与模拟信号发生联系时则必须经过转换电路对信号类型进行变换。

#### 数字电路

用来处理数字信号的电子线路称为数字电路。由于数字电路的各种功能是通过`逻辑运算和逻辑判断`来实现的，所以数字电路又称为数字逻辑电路或者逻辑电路。

数字电路特点有三：

- 二进制：数字电路一般都中采用二进制来表征数字信号，也就是说数字信号只有"0"和"1"两个值。
- 稳定性好：凡具有两个稳态的器件均可用来实现数字电路，电路允许器件有较大的分散性。
- 抗干扰能力强：数字电路传递、加工和处理的是二值信息，且高低电平指的是一定的电压范围，FF 不易受外界干扰。

这些特点便于信号的长期存储且能赋予一定的加密，通用性较强，分析工具为逻辑运算、结构简单等等。

#### 数字电路的分类

从器件的物理特性可以分为：

- TTL
- CMOS

从器件的逻辑特性可以分为：

- 组合逻辑电路
- 时序逻辑电路

这是根据一个电路是否有记忆功能来分类的。

从器件的规模可以分为：

- SSI
- MSI
- LSI
- VLSI

从上到下依次为小、中、大、极大。

::: tip 对组合/时序逻辑电路的详细阐述：
如果一个逻辑电路`在任何时刻的稳定输出仅取决于该时刻的输入，而与电路过去的输入无关`，则称为组合逻辑电路，故而不需要记忆功能。

如果一个逻辑电路`在任何时刻的稳定输出不仅取决于该时刻的输入，而且与过去的输入相关`，则称为时序逻辑电路。需要一些特定的模块来进行记忆；而根据是否有统一的时钟信号进行同步则又可进一步分为同步/异步时序逻辑电路。
:::

#### 数字电路的研究方法

对数字系统中逻辑电路的研究有俩主要任务：

- 逻辑分析：对一个已有的数字逻辑电路，研究它的工作性能和逻辑功能称为逻辑分析。

- 逻辑设计：根据提出的逻辑功能，在给定条件下构造出实现预定功能的逻辑电路称为逻辑设计，或者逻辑综合。

现在有很多种设计方法，这里按过不表。我们需要学习的应该还是传统方法。

### 计数制及其转换

#### R 进制

常用的进制有二/八/十/十六几种进制，它们都是 R 进制的情况之一。

广义地说，一种进位计数制包含着`基数和位权`两个基本的因素

基数指的是计数制中所用到的数字符号的个数。在基数为 R 计数制中，包含 0、1、…、R-1 共 R 个数字符号，进位规律是"逢 R 进一"。称为 R 进位计数制，简称 R 进制。

位权是指在一种进位计数制表示的数中，用来表明不同数位上数值大小的一个固定常数。不同数位有不同的位权，某一个数位的数值等于这一位的数字符号乘上与该位对应的位权。R 进制数的位权是 R 的整数次幂。

例如，十进制数的位权是 10 的整数次幂，其个位的位权为 10^0，十位的位权是 10^1。

R 进制数 N 可以两种方法表示，举个例子 10 进制 的 123

- 并列表示法： 123
- 按权展开法： 1* 10 ^ 2 + 2 * 10 ^ 1 + 3 \* 10 ^ 0

对于其它进制也一样。

关于不同数制的四则计算这里就省略了。

#### 数制转换

在这里主要讨论三种转换：十进制和二进制之间的转换、八进制和二进制之间的转换、十六进制和二进制之间的转换。

##### 十进制和二进制之间的转换

对于二进制数转换为十进制数，直接展开到十进制；

对于十进制数转换为二进制数，应该对整数和小数分别进行处理：对于整数直接除 2 取余；

对于小数部分则乘 2 直到小数部分为 0 或者达到规定精度要求。例子如下：

![](2025-06-17-18-25-44.png)

![](2025-06-17-18-26-33.png)

如果同时包含整数和小数的十进制数，则分别转换后合并即可。

##### 八进制和二进制之间的转换

由于八进制的基本数字符号 0 ～ 7 正好和 3 位二进制数的取值 000 ～ 111 对应。所以，二进制数与八进制数之间的转换可以按位进行。

二进制数转换成八进制数：以小数点为界，分别往高、往低每 3 位为一组，最后不足 3 位时用 0 补充，然后写出每组对应的八进制字符，即为相应八进制数。

举个例子：

二进制：11100101.010 -> 八进制：345.2

相反的，八进制转为二进制也是这么做

##### 十六进制和二进制之间的转换

方法和八进制和二进制之间的转换一样，举个例子：

十六进制：5A.B -> 二进制：1011010.1011

### 带符号的二进制数的代码表示

我们之前聊到数字系统中常用二进制来表示数，这被称作机器数/机器码。

常见的机器码有原码、反码和补码三种，权当复习一下：

#### 原码

符号位用 0 表示正，1 表示负；数值位保持不变。原码表示法又称为符号—数值表示法。

对于二进制小数，举个例子就能明白：

`X = +0.1011 ; Y = -0.1011`

则它们的源码分别为：

`A = 0.1011 ; B = 1.1011`

对于整数是一样的：

`X = +1101 ; Y = -1101`

它们的原码分别为：

`A = 01101 ; B = 11101`

由于原码的加减运算需要考虑符号和大小，需要引入反码和补码来克服这个缺点。

#### 反码

带符号二进制数的反码表示为：

- 符号位

  - 用 0 表示 正
  - 用 1 表示 负

- 数值位
  - 正数反码的数值位和真值的数值位相同
  - 负数反码的数值位是真值的数值位逐个取反

也就是，对于一对相反数的真值，它们分别的反码，逐位都是相反数。

当我们利用反码进行真值加减法运算时，均可通过加法实现，也就是：

`X - Y = X + (-Y)`

运算时，符号位和数值位一样参加运算。**当符号位有进位产生时，应将进位加到运算结果的最低位，才能得到最后结果。**

![](2025-06-17-20-14-10.png)

#### 补码

对于符号位和上面两种一样：

- 用 0 表示 正
- 用 1 表示 负

- 数值位
  - 正数反码的数值位和真值的数值位相同
  - 负数反码的数值位是真值的数值位逐个取反，**之后在最低位 +1**

同样的，运用补码进行加减运算时，也可以转换为加法，不过和反码有所不同：

运算时，符号位和数值位一样参加运算，若符号位有
进位产生，**则应将进位丢掉后才能得到正确结果。**

![](2025-06-17-20-14-27.png)

### 编码

#### 常用编码

用 4 位二进制代码对十进制数字符号进行编码，简称为二-十进制代码，也称为 BCD 码，常见的有 8421 码、2421 码和余 3 码。

![](2025-06-17-20-27-48.png)

##### 8421 码

8421 码，是用 4 位二进制码表示一位十进制字符的一种有权码，4 位二进制码从高位至低位的权依次为 2^3、2^2、2^1、2^0，即为 8、4、2、1

举个例子：

`10进制数：28 = 2进制数：11100 = 8421码：00101000`

##### 2421 码

用 4 位二进制码表示一位十进制字符的另一种有权码，4 位二进制码从高位至低位的权依次为 2、4、2、1,故称为 2421 码。

举个例子：

`2421码：1101 = 10进制数：7`

2421 码和十进制数之间的转换也是按位进行的。

::: warning 2421 码的特性

- 2421 码不具备单值性。例如，0101 和 1011 都对应十进制数字 5。为了与十进制字符一一对应，2421 码不允许出现 0101 ～ 1010 的 6 种状态。

- 2421 码是一种对 9 的自补代码。即一个数的 2421 码只要自身按位变反，便可得到该数对 9 的补数的 2421 码。

例如：

`4 - 0100 -> 5 - 1011`
:::

##### 余 3 码

是由 8421 码加上 0011 形成的一种无权码，由于它的每个字符编码比相应 8421 码多 3，故称为余 3 码。

例如，十进制字符 5 的余 3 码是 5 的 8421 码 0101 加上 0011 ，为 1000.

::: warning

- 余 3 码中不允许出现 0000、0001、0010、1101、1110 和 1111 六种状态
- 余 3 码与十进制数进行转换时，每位十进制数字的编码都应余 3。
- 余 3 码是一种对 9 的自补代码
  :::

#### 可靠性编码

为了减少或者发现代码在形成和传送过程中都可能发生的错误/提高系统的可靠性。形成了各种编码方法。下面，介绍两种常用的可靠性编码：

##### 格雷码

格雷码的特点是任意两个相邻的数，其格雷码仅有一位不同，这能避免代码形成或变换过程中产生的错误。

![](2025-06-17-20-54-48.png)

::: tip 为什么能避免代码在形成或者变换过程中产生错误?

数字系统中，数是用电子器件的状态表示的，数据的变化即器件状态的变化。如当数据按升序或降序变化时，若采用普通二进制数，则每次增 1 或者减 1 可能引起若干位发生变化。

比如 0111 变成 1000。

当电子器件变化速度不一致时，便会产生错误代码。

而格雷码因为相邻的数只有一位不同，从根本上杜绝了这种情况的发生。
:::

如果想要将二进制码转为格雷码可以参考下图：

![](2025-06-17-21-00-42.png)
![](2025-06-17-21-00-50.png)

而将格雷码转为二进制码，则是使用格雷码的最高位作为二进制的最高位，二进制次高位产生过程是使用二进制的高位和次高位格雷码相异或得到，其他位的值与次高位产生过程类似。

##### 奇偶检验码

奇偶检验码是一种用来检验代码在传送过程中是否产生错误的代码。

由两部分组成：

- 信息位：位数不限的一组二进制代码
- 奇偶检验位：仅有一位

有两种编码方式如下：

![](2025-06-17-21-09-33.png)

对于 8421 码的奇偶检验码：

![](2025-06-17-21-10-30.png)

::: tip 奇偶检验码的特点

- 编码简单、容易实现

- 只有检验能力，无法纠错

- 只能发现任何奇数个错误，对任何偶数个错误无法处理
  - 举个例子，1011001，偶校验位为 0，则发送原信息为 10110010 - 如果出现一个错误：变成了 10010010 ，经过校验可以发现； - 如果出现两个错误：变成了 10000010 ，经过校验发现还是偶数，则会通过。
    :::

#### 字符编码

数字系统中处理的数据除了数字之外，还有字母、运算符号、标点符号以及其他特殊符号,人们将这些符号统称为字符。所有字符在数字系统中必须用二进制编码表示，通常将其称为字符编码。

最常见的就是 ASCII 码，它使用 7 位二进制码 表示 128 种字符：

![](2025-06-17-21-18-26.png)

## 逻辑代数基础

### 逻辑代数基本概念

我们将从逻辑代数/逻辑变量/逻辑运算/逻辑函数来介绍。

#### 什么是逻辑代数？

逻辑代数 L 是一个封闭的代数系统，它由一个逻辑变量集 K，常量 0 和 1 以及"或"、"与"、"非"三种基本运算所构成，记为`L={ K, +, ·, ', 0, 1 }`。该系统应满足下列公理:

- 交换律
- 结合律
- 分配律
- 0-1 律
- 互补律

具体的公理描述可见 PPT2.1 P 3~4

#### 逻辑变量和逻辑运算

逻辑代数和普通代数一样，是用字母表示其值可以变化的量，即逻辑变量,在这里简称变量。所不同的是：

- 普通代数中，变量取值可为任意实数；而逻辑变量的取值只能为 0 或 1
- 逻辑值 0 或 1 是用来表示矛盾双方和判断真伪的形式符号，这也就意味着无大小和正负之分。数字系统中，开关状态、电压高低、晶体管导通状态均可用这两个逻辑值来表示。

---

逻辑代数种定义了 与、或、非 三种基本运算

##### 或运算

如果决定某一事件是否发生的多个条件中，只要有一个或一个以上条件成立，事件便可发生，则这种因果关系称之为"或"逻辑。

逻辑代数中，"或"逻辑用"或"运算描述。其运算符号为`+`。

表达式如下：

`F = A + B`

0 和 1 的或运算法则显然，不做赘述。

实现或运算关系的逻辑电路称为或门。例如并联开关 A、B 控制灯 F。

##### 与运算

如果决定某一事件发生的多个条件必须同时具备，事件才能发生，则这种因果关系称之为"与"逻辑。

在逻辑代数中，"与"逻辑关系用"与"运算描述。其运算符号为`·`。两变量"与"运算关系可表示为：

`F = A · B`

0 和 1 的与运算法则显然，不做赘述。

实现与运算关系的逻辑电路称为与门，例如串联开关 A、B 控制灯 F。

##### 非运算

如果某一事件的发生取决于条件的否定，即事件与事件发生的条件之间构成矛盾，则这种因果关系称为"非"逻辑。

在逻辑代数中，"非"逻辑用"非"运算描述。其运算符号为 `'` (撇号) 或在变量上方加一横杠 `¯`。"非"运算的逻辑关系可表示为：

`F = A'`

显然，0 非等于 1，1 非等于 0.

开关 A 和灯 F 并联，可以表示为非运算关系

#### 逻辑函数

逻辑代数中函数的定义与普通代数中函数的定义类似，
即随自变量变化的因变量。但和普通代数中函数的概念相
比，逻辑函数具有如下特点：

- 逻辑函数只能取 0 或 1
- 函数和变量之间的关系是由 与或非 三种基本运算决定的

逻辑函数有 3 种表示法，分别为逻辑表达式，真值表，卡诺图。

对于逻辑表达式：

- 非运算符下可以不加括号
- 与运算符一般可省略
- 运算优先规则：() > 非 > 与 > 或

对于真值表，有 n 个变量的逻辑函数，真值表有 2^n 行。

卡诺图是由表示逻辑变量所有取值组合的小方格所构成的平面图。卡诺图在函数简化问题很有用，后面会详细介绍，另外，下面是图例：

![](2025-06-18-15-53-17.png)

### 逻辑代数的基本定理和规则

#### 基本定理

根据前面我们给出的 5 个公理，我们可以推出 8 组常见的定理：

1.  **重叠律(等幂律)**

    - `A + A = A`
    - `A · A = A`

2.  **还原律(双重否定律)**

    - `(A')' = A`

3.  **吸收律**

    - `A + AB = A`
    - `A(A + B) = A`

4.  **冗余律**

    - `A + A'B = A + B`
    - `A(A' + B) = AB`

5.  **并项律**

    - `AB + AB' = A`
    - `(A + B)(A + B') = A`

6.  **反演律(德摩根定律)**

    - `(A + B)' = A' · B'`
    - `(A · B)' = A' + B'`

7.  **推广的德摩根定律**

    - `(A + B + C + ...)' = A' · B' · C' ...`
    - `(A · B · C · ...)' = A' + B' + C' ...`

8.  **一致性定理**
    - `AB + A'C + BC = AB + A'C`
    - `(A + B)(A' + C)(B + C) = (A + B)(A' + C)`

::: tip 关于一致性定理的证明如下：
![](2025-06-18-16-11-27.png)
:::

#### 重要规则

逻辑代数有 3 条重要规则，即代入规则、反演规则和对偶规则。

##### 代入规则

在任何逻辑等式中，如果以一个逻辑函数（或者逻辑表达式）代替等式中的某个变量，则等式仍然成立。

例如，在 `A + A' = 1` 中，如果用 `B+C` 代替 `A`，则有 `(B+C) + (B+C)' = 1`，该等式仍然成立。

##### 反演规则

求一个逻辑函数 F 的反函数 F'，可以遵循以下步骤：

1. 将 F 表达式中的 `·` 换成 `+`，`+` 换成 `·`。
2. 将 F 表达式中的 `0` 换成 `1`，`1` 换成 `0`。
3. 将 F 表达式中的原变量换成反变量，反变量换成原变量。

::: tip
需要注意的是，在变换时必须保持原有的运算顺序，必要时需要加括号。
:::

例如，`F = A(B+C) + D'`，其反函数为 `F' = (A' + B'C')(D)`。

##### 对偶规则

求一个逻辑函数 F 的对偶式 F_D，可以遵循以下步骤：

1. 将 F 表达式中的 `·` 换成 `+`，`+` 换成 `·`。
2. 将 F 表达式中的 `0` 换成 `1`，`1` 换成 `0`。

::: tip
变量本身保持不变。对偶规则表明，若一个逻辑等式成立，则其对偶式也一定成立。
:::

例如 `A + 1 = 1` 的对偶式是 `A · 0 = 0`。
`A + BC = (A+B)(A+C)` 的对偶式是 `A(B+C) = AB+AC`。

#### 复合逻辑

实际应用中广泛采用"与非"门、"或非"门、"与或非"门、"异或"门等门电路。这些门电路输出和输入之间的逻辑关系可由 3 种基本运算构成的复合运算来描述，故通常将这种逻辑关系称为复合逻辑，相应的逻辑门则称为复合门。

##### 与非逻辑 (NAND)

"与非"逻辑是先对输入信号进行"与"运算，然后再对"与"运算的结果进行"非"运算。
其逻辑表达式为：`F = (A · B)'`

##### 或非逻辑 (NOR)

"或非"逻辑是先对输入信号进行"或"运算，然后再对"或"运算的结果进行"非"运算。
其逻辑表达式为：`F = (A + B)'`

##### 与或非逻辑 (AND-OR-INVERT)

"与或非"逻辑是先对某些输入信号进行"与"运算，再将这些"与"运算的结果与其他输入信号进行"或"运算，最后对整个结果进行"非"运算。
例如，两路两输入与或非门的逻辑表达式为：`F = (AB + CD)'`

##### 异或逻辑 (XOR)

"异或"逻辑的规则是：当两个输入变量的取值不同时，输出为 1；当取值相同时，输出为 0。
其逻辑表达式为：`F = A ⊕ B = A'B + AB'`
"异或"也称为"半加"运算。

#### 同或逻辑 (XNOR)

"同或"逻辑的规则是：当两个输入变量的取值相同时，输出为 1；当取值不同时，输出为 0。它与"异或"逻辑互补。
其逻辑表达式为：`F = A ⊙ B = A'B' + AB`

### 逻辑函数的表示形式

任何一个逻辑函数，其表达式的形式都不是唯一的。下面从分析与应用的角度出发，介绍逻辑函数表达式的基本形式、标准形式及其相互转换。

#### 逻辑函数表达式的两种基本形式

##### 与-或表达式 (SOP)

由若干个"与"项（乘积项）进行"或"运算构成的表达式。
例如： `F = AB + BC + AC`

##### 或-与表达式 (POS)

由若干个"或"项（和项）进行"与"运算构成的表达式。
例如： `F = (A+B)(B+C)(A+C)`

#### 逻辑函数表达式的标准形式

为了使逻辑函数的表示具有唯一性，引入了标准形式。

##### 最小项和标准与-或表达式

- **最小项**：对于一个 n 变量的逻辑函数，一个包含全部 n 个变量的乘积项称为最小项。每个变量以原变量或反变量的形式出现一次。n 个变量共有 2^n 个最小项。
- **标准与-或表达式**：也称为**最小项规范式**，是由函数的全部最小项"或"运算构成的表达式。

例如，对于三变量函数 `F(A, B, C)`，最小项 `A'BC` (m3) 只有在 `A=0, B=1, C=1` 时值为 1。一个函数的标准与-或表达式就是所有使其值为 1 的最小项之和。
`F(A,B,C) = ∑m(i1, i2, ...)`

##### 最大项和标准或-与表达式

- **最大项**：对于一个 n 变量的逻辑函数，一个包含全部 n 个变量的和项称为最大项。每个变量以原变量或反变量的形式出现一次。n 个变量共有 2^n 个最大项。
- **标准或-与表达式**：也称为**最大项规范式**，是由函数的全部最大项"与"运算构成的表达式。

例如，对于三变量函数 `F(A, B, C)`，最大项 `A+B'+C'` (M3) 只有在 `A=0, B=1, C=1` 时值为 0。一个函数的标准或-与表达式就是所有使其值为 0 的最大项之积。
`F(A,B,C) = ∏M(j1, j2, ...)`

::: tip 最小项与最大项的关系
同一个下标 i 的最小项 mi 和最大项 Mi 互为反函数，即 `mi' = Mi`。
:::

#### 逻辑函数表达式的转换

##### 任意表达式 → 标准与-或表达式

1.  首先将表达式化为与-或形式。
2.  检查每个与项，如果缺少某个变量 `X`，则将该项乘以 `(X+X')`。
3.  展开表达式，并删除重复的最小项。

例如，将 `F = A + B'C` 化为标准与-或式：
`F = A(B+B')(C+C') + (A+A')B'C`
`= (AB+AB')(C+C') + AB'C + A'B'C`
`= ABC+ABC'+AB'C+AB'C' + AB'C + A'B'C`
`= ABC+ABC'+AB'C+AB'C' + A'B'C`
`= ∑m(1, 4, 5, 6, 7)`

##### 任意表达式 → 标准或-与表达式

1.  首先将表达式化为或-与形式。
2.  检查每个或项，如果缺少某个变量 `X`，则将该项加上 `XX'`。
3.  利用分配律 `(X+YZ)=(X+Y)(X+Z)` 展开，并删除重复的最大项。

##### 标准与-或式 ↔ 标准或-与式

利用最小项和最大项的互补关系。
如果一个 n 变量函数 `F = ∑m(i...)`，那么它的反函数 `F' = ∑m(j...)`，其中 `j` 是在 `0` 到 `2^n - 1` 中所有未在 `i` 中出现的下标。
对 `F'` 应用德摩根定律，即可得到 `F` 的标准或-与表达式 `F = ∏M(j...)`。

例如，`F(A,B,C) = ∑m(1, 4, 5, 6, 7)`，则其最大项下标为 `0, 2, 3`。
所以 `F(A,B,C) = ∏M(0, 2, 3)`。

### 逻辑函数化简

一般来说，逻辑函数表达式越简单，设计出来的相应逻辑电路也就越简单。

我们有 3 种常用方法：代数化简法、卡诺图化简法、列表化简法。这里我们只介绍前两个方法。

#### 代数化简法

代数化简法是利用逻辑代数的基本定律和定理，对逻辑表达式进行合并、吸收、消去等操作，以得到最简表达式的方法。这种方法比较灵活，但需要一定的技巧和经验，且难以判断结果是否为最简。

常用的技巧有：

1.  **并项**：利用 `AB + AB' = A` 来合并项。
2.  **吸收**：利用 `A + AB = A` 来吸收项。
3.  **消去**：利用 `A + A'B = A + B` 或一致性定理 `AB + A'C + BC = AB + A'C` 来消去冗余项。
4.  **配项**：乘以 `(A+A')` 或加上 `AA'` 来创造可以化简的项。

**示例：**
化简逻辑函数 `F = A'B'C + A'BC + AB'C`

```
F = A'C(B' + B) + AB'C  // 提取公因式 A'C
  = A'C · 1 + AB'C       // B' + B = 1
  = A'C + AB'C         //
  = C(A' + AB')          // 提取公因式 C
  = C(A' + B')           // A' + AB' = A' + B'
  = A'C + B'C          // 展开
```

#### 卡诺图化简法

卡诺图化简法是一种高效的图形化工具，用于简化布尔函数。它利用图形的邻接性直观地找出可以合并的最小项，从而得到最简的"与-或"表达式。对于含有 2 到 4 个变量的函数，此方法尤为直观和便捷。

##### 卡诺图的核心思想：逻辑相邻性

卡诺图的巧妙之处在于它的布局。所有小方格都按照格雷码的顺序排列，这保证了任何两个在物理上相邻（上下、左右、甚至首尾相卷）的方格，其对应的最小项只有一个变量是不同的。

::: tip 为什么逻辑相邻性很重要？
根据布尔代数的基本定理 `XY + XY' = X`，两个只有一个变量不同的最小项可以合并，并消去那个不同的变量。卡诺图通过将这些"逻辑相邻"的项在图中"物理相邻"，使得我们可以通过"圈圈"这种直观的方式，快速完成合并与化简。
:::

##### 卡诺图的结构

- **三变量卡诺图**

| A\BC  | 00  | 01  | 11  | 10  |
| :---: | :-: | :-: | :-: | :-: |
| **0** | m0  | m1  | m3  | m2  |
| **1** | m4  | m5  | m7  | m6  |

- **四变量卡诺图** (注意行列都是格雷码顺序 `00, 01, 11, 10`)

| AB\CD  | 00  | 01  | 11  | 10  |
| :----: | :-: | :-: | :-: | :-: |
| **00** | m0  | m1  | m3  | m2  |
| **01** | m4  | m5  | m7  | m6  |
| **11** | m12 | m13 | m15 | m14 |
| **10** | m8  | m9  | m11 | m10 |

##### 化简步骤与策略

1.  **绘制与填充卡诺图**：根据逻辑函数的真值表或最小项表达式，在卡诺图对应的小方格中填入"1"。函数值为"0"的方格留空即可。

2.  **圈出相邻的"1"**：用矩形圈包围相邻的"1"。

    - **圈图规则**：
      - 圈必须是矩形。
      - 圈内"1"的个数必须是 2 的整数次幂（1, 2, 4, 8, ...）。
      - 圈越大越好。一个包含 2^k 个"1"的圈可以消去 k 个变量。
      - 圈的总数越少越好，这对应于最简表达式中更少的乘积项。
      - 所有的"1"都必须被至少一个圈覆盖。
      - 为了画出更大的圈，一个"1"可以被重复圈在不同的圈中。
      - 记住卡诺图的边界是"卷曲"的，即第一行与最后一行相邻，第一列与最后一列相邻。

3.  **从圈写出最简与项**：每一个圈对应一个化简后的"与"项。

    - 观察圈内的所有方格。
    - 如果某个变量在圈内所有方格中都保持为"1"，则将该原变量写入项中。
    - 如果某个变量在圈内所有方格中都保持为"0"，则将该反变量写入项中。
    - 如果某个变量在圈内既有"0"也有"1"，说明该变量已被消去，不用写入项中。

4.  **合并与项**：将所有从圈中得到的"与"项进行"或"运算，就得到了最终的最简"与-或"表达式。

**示例：**
化简 `F(A,B,C) = ∑m(1, 4, 5, 6, 7)`

1.  **填图**:
    | A\BC | 00 | 01 | 11 | 10 |
    | :--: |:--:|:--:|:--:|:--:|
    | **0** | | 1 | | |
    | **1** | 1 | 1 | 1 | 1 |

2.  **圈"1"**:

    - **圈 1 (大圈)**: 圈起第二行的四个"1" (`m4, m5, m7, m6`)。
    - **圈 2 (竖圈)**: 圈起第二列的两个"1" (`m1, m5`)，注意 m5 被重复圈了。

3.  **写表达式**:

    - **分析圈 1**: 覆盖了 `m4(100), m5(101), m7(111), m6(110)`。
      - 变量 `A` 始终为 **1**。
      - 变量 `B` 和 `C` 都有 0 和 1，被消去。
      - -> 得到与项：`A`
    - **分析圈 2**: 覆盖了 `m1(001), m5(101)`。
      - 变量 `A` 有 0 和 1，被消去。
      - 变量 `B` 始终为 **0**。
      - 变量 `C` 始终为 **1**。
      - -> 得到与项：`B'C`

4.  **最终结果**: `F = A + B'C`

##### 处理无关项 (Don't Cares)

在某些实际电路中，一些输入组合永远不会出现，或者出现时输出是任意的，这些项称为**无关项**。

- 在卡诺图中，无关项通常用 `X` 或 `d` 标记。
- **策略**：在圈图时，你可以将 `X` 视为"1"来帮助你画出更大、更少的圈，以获得更简单的表达式。但是，你没有义务必须圈住任何一个 `X`。简单来说，**`X` 是你的"万能牌"，只在对你有利时使用它**。

##### 示例 2：四变量函数的边角化简

化简逻辑函数 `F(A,B,C,D) = ∑m(0, 2, 5, 7, 8, 10, 13, 15)`

1.  **填图**:
    | AB\CD | 00 | 01 | 11 | 10 |
    | :---: |:--:|:--:|:--:|:--:|
    | **00** | 1 | | | 1 |
    | **01** | | 1 | 1 | |
    | **11** | | 1 | 1 | |
    | **10** | 1 | | | 1 |

2.  **圈"1"**:

    - **圈 1 (四角)**: 将 `m0, m2, m8, m10` 四个角落的"1"圈起来。这是利用卡诺图上下、左右边界相邻的特性。
    - **圈 2 (中间)**: 将 `m5, m7, m13, m15` 四个"1"圈起来。

3.  **写表达式**:

    - **分析圈 1**: 覆盖了 `m0(0000), m2(0010), m8(1000), m10(1010)`。
      - 变量 `A` 和 `C` 都有 0 和 1，被消去。
      - 变量 `B` 始终为 **0**。
      - 变量 `D` 始终为 **0**。
      - -> 得到与项：`B'D'`
    - **分析圈 2**: 覆盖了 `m5(0101), m7(0111), m13(1101), m15(1111)`。
      - 变量 `A` 和 `C` 都有 0 和 1，被消去。
      - 变量 `B` 始终为 **1**。
      - 变量 `D` 始终为 **1**。
      - -> 得到与项：`BD`

4.  **最终结果**: `F = B'D' + BD`。这实际上是变量 B 和 D 的"同或"(`B ⊙ D`)。

##### 示例 3：含无关项的四变量函数化简

化简逻辑函数 `F(W,X,Y,Z) = ∑m(1,3,7,11,15)`，其中无关项为 `d(0,2,5)`。

1.  **填图 (1 代表最小项，X 代表无关项)**:
    | WX\YZ | 00 | 01 | 11 | 10 |
    | :---: |:--:|:--:|:--:|:--:|
    | **00** | X | 1 | 1 | X |
    | **01** | | X | 1 | |
    | **11** | | | 1 | |
    | **10** | | | 1 | |

2.  **圈"1" (利用"X")**:

    - **圈 1 (大圈)**: 为了覆盖 `m1, m3`，我们利用无关项 `X` 在 `m0, m2` 的位置，将 `m0, m1, m2, m3` 四个方格圈起来，形成一个更大的圈。
    - **圈 2 (竖圈)**: 将 `YZ` 列为 `11` 的所有项 (`m3, m7, 15, 11`) 圈起来。这是一个天然的四"1"圈。

3.  **写表达式**:

    - **分析圈 1**: 覆盖了 `m0(0000), m1(0001), m2(0010), m3(0011)`。
      - 变量 `W` 始终为 **0**。
      - 变量 `X` 始终为 **0**。
      - 变量 `Y` 和 `Z` 都有 0 和 1，被消去。
      - -> 得到与项：`W'X'`
    - **分析圈 2**: 覆盖了 `m3(0011), m7(0111), m15(1111), m11(1011)`。
      - 变量 `W` 和 `X` 都有 0 和 1，被消去。
      - 变量 `Y` 始终为 **1**。
      - 变量 `Z` 始终为 **1**。
      - -> 得到与项：`YZ`

4.  **最终结果**: `F = W'X' + YZ`。通过利用无关项，我们得到了比不使用它们（例如，只圈 `m1,m3` 得到 `W'X'Z`）更简洁的表达式。

## 集成门电路与触发器

根据所采用的半导体器件，可将数字集成电路分为两大类：双极型集成电路和单极型集成电路（MOS 管）。

在这两大类下又能分为更多小类，这里不做阐述。

### 半导体开关器件基础

数字电路中的晶体二极管、三极管和 MOS 管等器件一般是以开关方式运用的，其工作状态相当于开关的"接通"与"断开"。由于开关频率非常高，我们需要分析其在导通和截止两种状态下的静态和动态特性。

#### 晶体二极管 (Diode)

二极管是一个 PN 结，具有单向导电性，是实现逻辑运算最基础的元件之一。

- **导通 (ON)**: 当阳极(P)电压高于阴极(N)电压，且电压差超过开启电压（硅管约 0.5V~0.7V）时，二极管导通。此时可看作一个**闭合的开关**，并存在一个微小的正向压降 `V_F`。
- **截止 (OFF)**: 当阳极电压低于或等于阴极电压时，二极管截止。此时可看作一个**断开的开关**，仅有极小的反向漏电流通过。

| 状态           | 偏置条件                   | 等效模型        | 特点                   |
| :------------- | :------------------------- | :-------------- | :--------------------- |
| **导通 (ON)**  | 正向偏置 (`V_A > V_K`)     | 闭合开关 + 压降 | 电流较大，`V_F` ≈ 0.7V |
| **截止 (OFF)** | 反向或零偏置 (`V_A ≤ V_K`) | 断开开关        | 电流极小，`I_R` ≈ 0    |

#### 双极型晶体三极管 (BJT)

三极管（以 NPN 型为例）是电流控制器件，通过控制基极(b)电流 `I_B` 来控制集电极(c)和发射极(e)之间的通断。

- **截止状态 (Cutoff)**: 基极-发射极电压 `V_BE` 小于开启电压 (约 0.7V)，`I_B` ≈ 0。此时集电极电流 `I_C` ≈ 0，三极管相当于一个**断开的开关**。
- **饱和状态 (Saturation)**: `V_BE` > 0.7V，且有足够大的基极电流 `I_B` 流入，使三极管完全导通。此时集电极-发射极电压 `V_CE` 很小（约 0.2V~0.3V），三极管相当于一个**闭合的开关**。

在数字电路中，我们驱动三极管在截止和饱和两个极端状态之间切换，以避免工作在放大区而产生不确定的逻辑电平。

| 状态                  | 基极条件 (`I_B`)              | `V_CE`             | 等效模型 |
| :-------------------- | :---------------------------- | :----------------- | :------- |
| **截止 (Cutoff)**     | `I_B` ≈ 0                     | `V_CE` ≈ `V_CC`    | 断开开关 |
| **饱和 (Saturation)** | `I_B` > `I_BS` (饱和基极电流) | `V_CE(sat)` ≈ 0.3V | 闭合开关 |

#### MOS 场效应管 (MOSFET)

MOS 管是电压控制器件，通过控制栅极(G)和源极(S)之间的电压 `V_GS` 来控制漏极(D)和源极之间的通断。它是现代数字集成电路的核心。

- **截止状态 (Cutoff)**: 当栅源电压 `V_GS` 小于阈值电压 `V_T` 时，DS 之间没有导电沟道形成。此时 MOS 管相当于一个**断开的开关**。
- **导通状态 (ON)**: 当 `V_GS` 远大于阈值电压 `V_T` 时，DS 之间形成导电沟道，MOS 管导通。此时它相当于一个**闭合的开关**，其导通电阻 `R_on` 很小。

::: tip MOS 管的关键优势

1.  **电压控制**：栅极和沟道之间是绝缘的，输入阻抗极高，因此几乎不消耗静态驱动电流。
2.  **功耗低**：由 NMOS 和 PMOS 管构成的 CMOS（互补金属氧化物半导体）电路，在静态时总有一个管子截止，理论上静态功耗为零，这是它在超大规模集成电路中占主导地位的关键。
:::

### 逻辑门电路

实现基本和复合逻辑运算的电子电路被称为**逻辑门**。它们是构建任何数字系统的基础模块。在深入了解 TTL 和 CMOS 等集成电路家族之前，我们先看看如何用基础的分立元件搭建简单的逻辑门。

#### 0. 简单门电路的构建原理与符号

##### 二极管逻辑 (Diode Logic - DL)
用二极管和电阻可以搭建最简单的"与"门和"或"门。

-   **二极管"与"门**:
    -   **结构**: 多个输入通过各自的二极管连接到一个公共点，该点通过一个上拉电阻 `R` 连接到高电平 `VCC`。输出 `Y` 从该公共点取出。二极管的阳极是输入端，阴极连接到公共点。
    -   **原理**: 只有当**所有**输入均为高电平时，所有二极管都截止，输出 `Y` 被上拉到高电平。只要有**任何一个**输入为低电平，对应的二极管就会导通，将输出 `Y` 拉到接近低电平。
    -   **结论**: 实现了 `Y = A · B` 的"与"逻辑。

-   **二极管"或"门**:
    -   **结构**: 多个输入通过各自的二极管连接到一个公共点，该点通过一个下拉电阻 `R` 连接到地。输出 `Y` 从该公共点取出。二极管的阴极是输入端，阳极连接到公共点。
    -   **原理**: 只要有**任何一个**输入为高电平，对应的二极管就会导通，将输出 `Y` 拉到接近高电平。只有当**所有**输入都为低电平时，所有二极管都截止，输出 `Y` 被下拉到低电平。
    -   **结论**: 实现了 `Y = A + B` 的"或"逻辑。

##### 二极管-晶体管逻辑 (DTL)
DL 电路很简单但驱动能力差且会造成电平偏移。通过在后面加一个三极管反相器，就构成了更实用的 DTL 门电路，这也是 TTL 电路的雏形。

-   **DTL"与非"门 (NAND)**:
    -   **结构**: 一个二极管"与"门的输出，连接到一个 BJT 三极管的基极。三极管的发射极接地，集电极通过一个上拉电阻连接到 `VCC`，输出 `Y` 从集电极取出。
    -   **原理**:
        1.  当**所有**输入都为高电平时，二极管"与"部分输出高电平，这个高电平使三极管**饱和导通**，于是集电极被拉到低电平，输出 `Y` 为**低**。
        2.  当**任何一个**输入为低电平时，二极管"与"部分输出低电平，三极管因基极电压过低而**截止**，于是输出 `Y` 被上拉电阻拉到高电平，输出 `Y` 为**高**。
    -   **结论**: 实现了 `Y = (A · B)'` 的"与非"逻辑。

-   **DTL"或非"门 (NOR)**:
    -   **结构**: 将前端的二极管"与"门换成二极管"或"门，再连接到三极管反相器。
    -   **原理**: 任何一个输入为高，都会使三极管导通，输出为低。
    -   **结论**: 实现了 `Y = (A + B)'` 的"或非"逻辑。

##### 常用逻辑门符号
| 门类型 | 逻辑功能 | 符号特征 |
| :--- | :--- | :--- |
| **非 (NOT)** | `Y = A'` | 三角形后跟一个小圆圈 |
| **与 (AND)** | `Y = A · B` | D 形 |
| **或 (OR)** | `Y = A + B` | 弧形输入边，尖头输出 |
| **与非 (NAND)** | `Y = (A · B)'` | D 形后跟一个小圆圈 |
| **或非 (NOR)** | `Y = (A + B)'` | 弧形输入边，尖头输出，后跟一个小圆圈 |
| **异或 (XOR)** | `Y = A ⊕ B` | 在"或"门符号前加一条弧线 |


本节将重点介绍两种主流的集成逻辑门电路技术：TTL 和 CMOS，以及一些特殊用途的门电路。

#### 1. 主要技术分类与特性参数

-   **技术分类**:
    -   **TTL (Transistor-Transistor Logic)**: 双极型集成电路，速度快，但功耗较大。在早期中小规模集成电路中广泛使用。
    -   **CMOS (Complementary MOS)**: 单极型集成电路，功耗极低，集成度高，抗干扰能力强。是现代大规模和超大规模集成电路的主流技术。

-   **关键特性参数**:
    -   **高/低电平 (V_OH / V_OL)**: 门电路输出逻辑"1"和逻辑"0"时对应的电压。
    -   **噪声容限 (Noise Margin)**: 电路抵抗噪声干扰的能力。容限越大，电路工作越可靠。
    -   **传输延迟时间 (t_pd)**: 输入信号变化到输出信号相应变化所需的时间，决定了门电路的开关速度。
    -   **功耗 (Power Dissipation)**: 门电路工作时消耗的能量。

#### 2. TTL 门电路

TTL 电路以BJT三极管为核心，通常使用 `+5V` 电源。

-   **基本结构 (以与非门为例)**:
    -   **输入级**: 采用一个多发射极三极管，实现输入的"与"逻辑。
    -   **中间级 (相位倒相级)**: 提供电压放大和逻辑倒相。
    -   **输出级 (推拉式)**: 提供足够的驱动能力，实现快速的电平转换。
-   **工作原理总结 (与非门)**:
    -   当所有输入都为高电平时，输出为低电平。
    -   只要任一输入为低电平，输出就为高电平。
    -   逻辑功能: `F = (A · B · ...)'`
-   **典型系列**: 74/54系列，如 `74LS00` (四-2输入与非门)。

#### 3. CMOS 门电路

CMOS 电路的核心是由一个 **P-MOS管** 和一个 **N-MOS管** 互补构成的单元。

-   **基本结构 (以反相器为例)**:
    -   P-MOS管和N-MOS管的源极和漏极串联。
    -   输入信号 `A` 同时连接到两个管的栅极。
    -   当 `A` 为低电平 (0) 时: P-MOS导通，N-MOS截止，输出 `Y` 被上拉到高电平 (`V_DD`)。
    -   当 `A` 为高电平 (1) 时: N-MOS导通，P-MOS截止，输出 `Y` 被下拉到低电平 (GND)。
-   **核心优势**:
    -   **极低静态功耗**: 在稳定状态（输入为高或低），总有一个MOS管处于截止状态，几乎没有静态电流，非常省电。
    -   **高抗干扰能力**: 噪声容限大。
    -   **宽电源电压范围**: 可以在很宽的电压下工作（例如3V-18V）。
-   **典型系列**: 4000系列 和 高速的 74HC/HCT 系列。

#### 4. 特殊用途的门电路

##### 集电极开路门 (OC/OD Gate)

-   **结构**: 输出级没有内部的上拉电阻，集电极（或漏极）是开路的。
-   **使用**: 必须外接一个上拉电阻到电源。
-   **核心用途**:
    -   **线与 (Wired-AND)**: 将多个OC门的输出直接连接在一起，可以实现"与"逻辑。只要有一个门的输出为低电平，就会将整条线拉低。`Y = Y1 · Y2 · Y3 ...`
    -   **电平转换**: 通过选择合适的上拉电阻和电源，可以实现不同逻辑电平家族之间的接口。

##### 三态门 (Tri-state Gate)

-   **三种状态**:
    -   **高电平 (1)**
    -   **低电平 (0)**
    -   **高阻态 (Hi-Z)**: 输出端相当于与电路内部断开，既不输出高电平也不输出低电平。
-   **控制**: 由一个额外的**使能端(Enable, EN)**控制。EN有效时，门工作在正常逻辑状态；EN无效时，门输出高阻态。
-   **核心用途**:
    -   **总线系统**: 计算机中的CPU、内存、外设等需要共享同一组数据线（总线）。通过三态门，可以确保在任何时刻只有一个设备向总线发送数据，其他设备都处于高阻态，避免信号冲突。

#### 5. TTL 与 CMOS 的比较

| 特性         | TTL                                  | CMOS                                         |
| :----------- | :----------------------------------- | :------------------------------------------- |
| **功耗**     | 较大，特别是静态功耗                   | 极低，主要在开关瞬间有动态功耗               |
| **速度**     | 早期速度快，但现代CMOS技术已超越       | 早期较慢，现已非常快                       |
| **噪声容限**   | 较小                                 | 较大，抗干扰能力强                         |
| **电源电压**   | 严格，通常为 5V ± 5%                 | 范围宽，如 3V ~ 18V                        |
| **集成度**   | 较低                                 | 非常高，适用于LSI和VLSI                    |

#### 6. 正逻辑和负逻辑

这是一个约定问题：
- **正逻辑** (常用): 高电平 (H) 代表逻辑 `1`，低电平 (L) 代表逻辑 `0`。
- **负逻辑**: 低电平 (L) 代表逻辑 `1`，高电平 (H) 代表逻辑 `0`。

同一个物理电路，在正逻辑和负逻辑约定下，其逻辑功能是不同的。例如，一个正逻辑的"与非"门，在负逻辑下就是一个"或非"门。除非特殊说明，否则我们总是默认使用**正逻辑**。

### 触发器

与任何时刻的输出仅取决于该时刻输入的组合逻辑电路不同，时序逻辑电路具有**记忆功能**，其输出不仅取决于当前输入，还与电路之前的状态有关。实现这种记忆功能的基本单元就是**触发器 (Flip-flop)**。

触发器是能够存储一位 (bit) 二进制信息的最小单元。它具有两个可以自我维持的稳定状态，通常用 `0` 和 `1` 来表示。触发器有两个互补的输出端：`Q` 和 `\overline{Q}`。在输入信号的作用下，触发器可以从一个状态转换到另一个状态。我们通常将触发器在输入信号作用前的状态称为**现态**（用 `Q^n` 表示），变化后的新状态称为**次态**（用 `Q^{n+1}` 表示）。

#### 1. 基本 R-S 锁存器 (Basic RS Latch)

基本 R-S 锁存器是构成各种复杂触发器的基础，也是最简单的记忆元件。它通常由两个与非门或或非门交叉耦合而成。

##### 由"与非"门构成的基本 R-S 锁存器

这种锁存器由两个与非门交叉连接构成。它的输入端是低电平有效的，通常记为 `\overline{S}` (置位 Set) 和 `\overline{R}` (复位 Reset)。

-   **工作原理**:
    -   **置位 (Set)**: 当 `\overline{S}=0`, `\overline{R}=1` 时，无论 `Q` 此前为何状态，输出 `Q` 都会被强制置为 `1`。
    -   **复位 (Reset)**: 当 `\overline{S}=1`, `\overline{R}=0` 时，输出 `Q` 会被强制置为 `0`。
    -   **保持 (Hold)**: 当 `\overline{S}=1`, `\overline{R}=1` 时，两个与非门的输入都依赖于另一门的输出。此时，电路会维持在之前的状态不变，即 `Q^{n+1} = Q^n`。这体现了锁存器的"记忆"功能。
    -   **禁止 (Forbidden)**: 当 `\overline{S}=0`, `\overline{R}=0` 时，`Q` 和 `\overline{Q}` 的输出都会被强制为 `1`，这违反了它们互补的约定。并且，如果 `\overline{S}` 和 `\overline{R}` 同时跳回 `1`，锁存器的最终状态将不确定。因此，这个输入组合是被禁止使用的。

| \(\overline{S}\) | \(\overline{R}\) | \(Q^{n+1}\) | 功能说明 |
| :---: | :---: | :---: | :--- |
| 0 | 0 | 不定 | 禁止 |
| 0 | 1 | 1 | 置位 |
| 1 | 0 | 0 | 复位 |
| 1 | 1 | \(Q^n\) | 保持 |

##### 由"或非"门构成的基本 R-S 锁存器

这种锁存器的输入端是高电平有效的，记为 `S` 和 `R`。其逻辑功能与与非门锁存器类似，但触发电平相反。它的禁止状态发生在 `S=1, R=1`。

| S | R | \(Q^{n+1}\) | 功能说明 |
| :-: | :-: | :---: | :--- |
| 0 | 0 | \(Q^n\) | 保持 |
| 0 | 1 | 0 | 复位 |
| 1 | 0 | 1 | 置位 |
| 1 | 1 | 不定 | 禁止 |

其特性方程为：\(Q^{n+1} = S + \overline{R}Q^n\)，约束条件为 `S · R = 0`。

基本 R-S 锁存器结构简单，但它对输入信号的变化是即时响应的，这使得在复杂系统中难以精确控制状态翻转的时刻。

#### 2. 时钟控制与触发方式

为了让触发器只在特定的时刻（例如，在统一的**时钟 (Clock, CLK)** 信号控制下）才接收输入并改变状态，我们引入了同步触发器。

最简单的同步触发器是在基本 R-S 锁存器的输入端前增加两个控制门（与门）。只有当时钟信号 `CLK=1` 时，输入 `S` 和 `R` 才能影响锁存器；当 `CLK=0` 时，无论 `S` 和 `R` 如何变化，触发器都保持原状态。

然而，这种简单的**电平触发**同步方式存在"**空翻**" (Racing) 问题：在 `CLK=1` 的整个时间段内，如果输入信号 `S` 或 `R` 发生多次变化，输出 `Q` 也会跟着多次翻转，这使得电路的最终状态不可控。

为了解决这个问题，现代触发器采用**边沿触发 (Edge-Triggered)** 方式。这意味着触发器只在时钟信号的**上升沿** (从0到1的瞬间) 或**下降沿** (从1到0的瞬间) 才对输入进行采样并改变状态，而忽略在时钟电平保持稳定期间的任何输入变化。这确保了每个时钟周期只发生一次确定的状态转换。早期的**主从触发器 (Master-Slave Flip-flop)** 也是为了解决空翻问题而设计的，其效果类似于下降沿触发。

#### 3. 现代触发器类型

为了克服基本R-S触发器的输入约束和不确定性问题，人们设计出了功能更完善的触发器。

##### D 触发器 (D Flip-flop)

D 触发器通过在内部连接 `S` 和 `R` 输入，确保它们永远互补（`S=D`, `R=\overline{D}`），从而彻底解决了 `S=R=1` 的禁止状态问题。

-   **核心功能**：在时钟的有效边沿，将输入 `D` 的值锁存到输出 `Q` 上，即 `Q^{n+1} = D`。
-   **用途**：由于它能"延迟"一个时钟周期再输出数据，常被称为**数据 (Data)** 或**延迟 (Delay)** 触发器，是构建寄存器和存储单元的基础。

##### J-K 触发器 (J-K Flip-flop)

J-K 触发器是功能最全面的触发器。它不仅解决了 R-S 触发器的不确定状态，还增加了一个全新的功能。

-   **工作原理**：它有两个输入端 `J` 和 `K`，其功能可以看作是 R-S 触发器的增强版 (`J` 对应 `S`, `K` 对应 `R`)。
    -   `J=0, K=0`：**保持**状态。
    -   `J=1, K=0`：**置位** (Set)，`Q` 置为 `1`。
    -   `J=0, K=1`：**复位** (Reset)，`Q` 置为 `0`。
    -   `J=1, K=1`：**翻转 (Toggle)**，`Q` 的状态取反，即 `Q^{n+1} = \overline{Q^n}`。这是它独有的功能。
-   **特性方程**：`Q^{n+1} = J\overline{Q^n} + \overline{K}Q^n`。

##### T 触发器 (T Flip-flop)

T 触发器是 J-K 触发器的一个简化特例，将 `J` 和 `K` 输入连接在一起，形成单个输入 `T`。

-   **核心功能**：
    -   `T=0`：**保持**状态。
    -   `T=1`：**翻转**状态。
-   **特性方程**：`Q^{n+1} = T \oplus Q^n = T\overline{Q^n} + \overline{T}Q^n`。
-   **用途**：由于其便捷的翻转功能，T 触发器是构建**计数器**的理想选择。

## 组合逻辑电路

我们将从4个小节来学习组合逻辑电路：

- 基本概念
- 分析和设计的基本方法
- 设计中的几个常见问题及处理
- 竞争与险象问题

### 1. 基本概念

**组合逻辑电路 (Combinational Logic Circuit)** 是指在任何时刻，电路的稳定输出仅仅取决于该时刻的输入信号组合，而与电路过去的状态无关。简而言之，它是一个**没有记忆功能**的电路。

这与我们之前讨论的触发器构成的**时序逻辑电路**形成了鲜明对比。组合逻辑电路的基本构成单元是各种逻辑门，其结构特点是：
- 电路中不包含任何反馈回路（即任何门的输出都不会再经过一系列门后回到其输入端）。
- 任何一组确定的输入，都对应一组唯一确定的输出。

因此，任何一个组合逻辑电路的功能都可以用一个或一组布尔函数来完全描述。

### 2. 分析和设计的基本方法

#### 组合逻辑电路的分析

分析是指对于一个给定的逻辑电路图，确定其逻辑功能的过程。基本步骤如下：

1.  **写出逻辑表达式**：从电路的输入端开始，逐级向输出端写出每个逻辑门的输出表达式，直到得到最终输出 `F` 关于所有输入变量的完整表达式。
2.  **化简表达式**：利用逻辑代数或卡诺图等方法，将得到的逻辑表达式化为最简形式。
3.  **列出真值表**：根据最终的逻辑表达式，列出所有输入组合对应的输出值，从而得到电路的真值表。
4.  **描述逻辑功能**：根据真值表或最简表达式，用文字描述该电路所实现的逻辑功能（例如："三输入多数表决器"或"两位二进制数比较器"等）。

**示例：**
分析下图所示电路的功能（此处假设一个电路图）：
一个电路，输入为A, B, C。A和B输入一个与门G1，B和C输入一个与门G2，G1和G2的输出再输入一个或门G3，G3的输出为F。

1.  **写表达式**：`F = (A · B) + (B · C)`
2.  **化简**：该表达式已为最简"与-或"式。
3.  **真值表**:

| A | B | C | F |
|---|---|---|---|
| 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 0 |
| 0 | 1 | 0 | 0 |
| 0 | 1 | 1 | 1 |
| 1 | 0 | 0 | 0 |
| 1 | 0 | 1 | 0 |
| 1 | 1 | 0 | 1 |
| 1 | 1 | 1 | 1 |
1.  **功能描述**：当输入B为1，且A或C中至少有一个为1时，输出F为1。

#### 组合逻辑电路的设计

设计是分析的逆过程，即根据提出的逻辑需求，设计出实现该功能的电路。这是数字系统设计的核心环节之一。

1.  **逻辑抽象**：这是最关键的一步。分析实际问题，确定输入和输出变量，并用真值表、逻辑表达式或文字描述等方式，准确定义输入和输出之间的逻辑关系。
2.  **写出逻辑表达式**：根据真值表，写出标准"与-或"（SOP）或"或-与"（POS）表达式。通常选择SOP形式，即所有使输出为1的最小项之和。
3.  **化简逻辑表达式**：使用卡诺图或代数法，将表达式化为最简形式，以减少所需逻辑门的数量和成本。
4.  **画出逻辑图**：根据最简表达式，选用合适的逻辑门（如与门、或门、非门，或仅用与非门/或非门），画出电路连接图。

**示例：设计一个三输入多数表决器**
需求：有三个裁判 A, B, C。当有两个或两个以上赞成时（以'1'代表赞成），表决结果 F 为通过('1')。

1.  **逻辑抽象（真值表）**:

| A | B | C | F |
|---|---|---|---|
| 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 0 |
| 0 | 1 | 0 | 0 |
| 0 | 1 | 1 | 1 |
| 1 | 0 | 0 | 0 |
| 1 | 0 | 1 | 1 |
| 1 | 1 | 0 | 1 |
| 1 | 1 | 1 | 1 |

1.  **写表达式 (SOP)**:
    `F = A'BC + AB'C + ABC' + ABC`

2.  **卡诺图化简**:

    | A\BC | 00 | 01 | 11 | 10 |
    | :--: |:--:|:--:|:--:|:--:|
    | **0** | | | 1 | |
    | **1** | | 1 | 1 | 1 |
    - 圈 `m3, m7` -> `BC`
    - 圈 `m5, m7` -> `AC`
    - 圈 `m6, m7` -> `AB`
    化简后得到：`F = AB + BC + AC`

3.  **画逻辑图**：用三个二输入与门和一个三输入或门即可实现。

### 3. 设计中的常见问题及处理

在实际设计中，除了使用基本的逻辑门（小规模集成，SSI）从零开始搭建，更高效的方法是利用功能更强的**中规模集成 (MSI) 电路**，如译码器、数据选择器、加法器等。

#### 利用译码器实现组合逻辑

**译码器 (Decoder)** 是一种将二进制代码转换为特定输出信号的电路。一个 n 输入的译码器有 2^n 个输出，每个输出对应一个最小项。在任何时候，只有一个输出被激活。

利用一个 n 输入的译码器和一个或门，可以实现任何 n 变量的组合逻辑函数：
1.  将函数的 n 个变量连接到译码器的 n 个输入端。
2.  找出函数表达式中所有使输出为 1 的最小项。
3.  将译码器上与这些最小项对应的输出端，全部连接到一个或门的输入端。或门的输出就是所求的函数 `F`。

例如，要实现 `F(A,B,C) = ∑m(1,4,6,7)`，只需使用一个 3-8 译码器，并将 `Y1, Y4, Y6, Y7` 这四个输出端连接到一个四输入或门即可。

#### 利用数据选择器实现组合逻辑

**数据选择器 (Multiplexer, MUX)** 的作用是从多个数据输入中，根据选择控制信号，选择其中一个送到唯一的输出端。一个有 n 个选择输入端的 MUX 可以从 2^n 个数据输入中选择一个。

利用 MUX 实现组合逻辑函数非常灵活。对于一个 n 变量的函数：
-   使用一个有 n 个选择端、2^n 个数据输入的 MUX（如用 8-1 MUX 实现 3 变量函数）。将 n 个变量连接到选择端，然后根据函数的真值表，将每个数据输入端 `D_i` 接到高电平(1)或低电平(0)，即可实现。
-   更巧妙地，使用一个有 n-1 个选择端、2^(n-1) 个数据输入的 MUX。将前 n-1 个变量连接到选择端，最后一个变量（例如 D）及其反相 `\overline{D}` 用于数据输入端。这样可以大大简化设计。

### 4. 竞争与险象问题

在理想情况下，我们假设逻辑门的开关是瞬时的。但在物理世界中，任何门电路都有**传输延迟**。当一个输入信号的变化需要通过不同数量的逻辑门（即不同延迟的路径）才能到达输出端时，就会发生**竞争 (Race)**。

竞争可能导致电路的输出端产生不应有的、短暂的错误信号（毛刺或尖峰脉冲），这种现象称为**险象 (Hazard)**。

#### 险象的类型

-   **静态险象 (Static Hazard)**: 在输入变化后，理论上输出应保持不变，但实际上却出现了一个短暂的毛刺。
    -   **静态-1 险象**: 输出应保持为 `1`，但瞬间跳变为 `0` 又恢复为 `1`。
    -   **静态-0 险象**: 输出应保持为 `0`，但瞬间跳变为 `1` 又恢复为 `0`。
-   **动态险象 (Dynamic Hazard)**: 在输入变化后，理论上输出应从一个值变为另一个值（如 `0`→`1`），但实际上却经过了多次跳变（如 `0`→`1`→`0`→`1`）。

#### 险象的识别与消除（以静态-1险象为例）

静态-1险象主要发生在"与-或"式（SOP）电路中。在卡诺图上，它通常发生在**两个相邻的 '1' 分别被不同的圈（积项）所覆盖**的情况下。当输入信号恰好在这两个相邻的最小项之间转换时，由于延迟，可能出现一个短暂的瞬间，所有积项的输出都为0，导致最终输出产生一个 `1`→`0`→`1` 的毛刺。

**消除方法**：在卡诺图中，增加一个**冗余的圈（冗余积项）**，将原来未被同一个圈覆盖的相邻 '1' 连接起来。这个冗余项在逻辑上是多余的（根据吸收律可以被消掉），但它在物理上提供了一个稳定的信号路径，确保在输入切换过程中，至少有一个积项的输出保持为 `1`，从而消除毛刺。

**示例：**
考虑函数 `F = A'C + BC`。
-   当 A=1, B=1 时，函数值为 `F = 0·C + 1·C = C`。
-   当 B=1, C=1 时，函数值为 `F = A'·1 + 1·1 = A' + 1 = 1`。

现在，假设输入状态为 `A=1, B=1, C=1`，此时 `A'C=0`, `BC=1`，所以 `F=1`。
如果输入 `A` 从 `1` 变为 `0`，而 `B` 和 `C` 保持为 `1`。理论上次态应为 `A=0, B=1, C=1`，`A'C=1`, `BC=1`，所以 `F` 仍然是 `1`。

然而，A 的变化需要经过一个非门才能影响 `A'C` 项。如果这个非门的延迟比 `A` 直接到其他路径的延迟要长，那么在短暂的瞬间，电路看到的可能是 `A=0` 和 `A'=0`（旧值）。此时：
-   `A'C` 项的输入为 `A'=0, C=1` -> 输出 0
-   `BC` 项不受 A 影响，但如果原始函数是 `AB + A'C`，那么 `AB` 项变为 0。
让我们用一个更经典的例子：`F = AB + A'C`。
假设 `B=1, C=1`，此时 `F = A + A'` 应该是 `1`。如果 `A` 从 `1` 变为 `0`，`AB` 项从 `1` 变为 `0`，而 `A'C` 项从 `0` 变为 `1`。如果 `A` 到 `AB` 项的路径比 `A` 经过非门再到 `A'C` 项的路径快，那么 `AB` 会先变为 `0`，而 `A'C` 尚未变为 `1`，导致 `F` 短暂地输出 `0`。

**K图分析与解决**:
函数 `F = AB + A'C` 的卡诺图上，`m7(111)` 被 `AB` 圈覆盖，`m3(011)` 被 `A'C` 圈覆盖。这两个'1'是相邻的，但被不同的圈覆盖。当输入从 `111` 变为 `011` 时，就可能发生险象。

**解决方法**：在卡诺图中加一个冗余圈，把 `m7` 和 `m3` 圈在一起。这个冗余圈对应的积项是 `BC`。
新的无险象函数为 `F = AB + A'C + BC`。
现在，当 `B=1, C=1` 时，冗余项 `BC` 的值恒为 `1`。无论 `A` 如何变化，由于 `BC` 项的存在，总输出 `F` 会稳定地保持在 `1`，从而消除了险象。


































































